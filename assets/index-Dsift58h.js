(function(){const i=document.createElement("link").relList;if(i&&i.supports&&i.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const t of e)if(t.type==="childList")for(const a of t.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?t.credentials="include":e.crossOrigin==="anonymous"?t.credentials="omit":t.credentials="same-origin",t}function r(e){if(e.ep)return;e.ep=!0;const t=n(e);fetch(e.href,t)}})();const l=`
1) Дайте понятие системы контроля версий. Приведите примеры
систем контроля версий.
Система контроля версий (СКВ) - это инструмент, используемый для
управления изменениями в файловой системе и отслеживания версий файлов.
Она позволяет разработчикам работать одновременно над проектом,
отслеживать изменения, вносить исправления и возвращаться к предыдущим
версиям файлов при необходимости. Примеры систем контроля версий
включают Git, Subversion (SVN), Mercurial, CVS и другие.
2) Опишите разницу между полным и инкрементальным
копированием в системах контроля версий
Полное копирование в системах контроля версий означает сохранение
полной копии всех файлов и папок на каждый момент времени, когда
выполняется фиксация (commit). Инкрементальное копирование же сохраняет
только различия (патчи) между версиями файлов, что позволяет экономить
место на диске и ускоряет операции с системой контроля версий.
3) Опишите возможности систем управления версиями
Системы управления версиями предоставляют следующие возможности:
- Отслеживание изменений в файлах и папках.
- Фиксация версий файлов и возврат к предыдущим версиям.
- Создание веток для разработки параллельных версий проекта.
- Слияние изменений из разных веток.
- Разрешение конфликтов при слиянии изменений.
- Маркировка версий с помощью тегов и комментирование изменений.
- Просмотр истории изменений для отслеживания внесенных правок.
4) Особенности и недостатки работы локальных систем контроля
версий на примере системы RCS.
Локальные системы контроля версий, например, RCS (Revision Control
System), хранят файлы и историю изменений непосредственно на локальном
компьютере разработчика. Они обладают простым и быстрым интерфейсом,
но ограничены в возможностях совместной работы и синхронизации
изменений между разными участниками проекта. Такие системы не
предоставляют удаленного доступа к репозиторию и не подходят для
командной разработки.

5) Особенности и недостатки работы централизованных систем
контроля версий на примере систем CVS, Subversion и Perforce.
Централизованные системы контроля версий (CVS, Subversion, Perforce)
используют центральный сервер, на котором хранится репозиторий.
Разработчики выполняют операции с версиями файлов, обращаясь к серверу.
Особенности централизованных систем включают общую историю изменений,
централизованное управление правами доступа и возможность слияния
изменений. Однако, они могут стать узким местом в разработке при высокой
нагрузке на сервер или при отсутствии подключения к сети
6) Особенности и недостатки работы распределенных систем
контроля версий на примере системы Git.
Распределенные системы контроля версий, такие как Git, предоставляют
каждому разработчику полную копию репозитория, включая всю историю
изменений. Это позволяет работать независимо и офлайн, а также
обеспечивает более гибкую работу с ветками, слияниями и разрешением
конфликтов. Распределенные системы также обладают высокой
отказоустойчивостью, так как у каждого участника есть полная копия
данных.
7) Дайте определение понятию «репозиторий». Локальные и
удаленные репозитории.
Репозиторий - это хранилище файлов и истории изменений в системе
контроля версий. Локальный репозиторий расположен на компьютере
разработчика и содержит копию файлов и их версий. Удаленный репозиторий
находится на сервере и обеспечивает доступ и совместную работу
разработчиков с проектом. Локальный репозиторий служит для локальных
операций и фиксаций, а удаленный репозиторий - для совместной работы и
обмена изменениями между участниками проекта.
8) Для каких целей используются частные(приватные) и открытые
репозитории
Частные (приватные) репозитории используются для хранения и управления
проектами, которые не предназначены для публичного доступа. Они
обеспечивают конфиденциальность кода и данных, позволяют ограничивать

доступ к проекту только определенным пользователям или команде
разработчиков. Открытые репозитории, напротив, предназначены для
публичного доступа и совместной работы с широкой аудиторией. Они
позволяют другим разработчикам вносить вклад в проект, делать форки и
отправлять запросы на слияние изменений.
9) Ведение версий в системах контроля версий (возможности по
работе с локальным и удаленным репозиторием; версии и фиксации; ветки и
работа с ними; слияния и разрешения конфликтов; варианты отката
изменений; теги и комментирование; возможности по просмотру истории
изменений).
Системы контроля версий предоставляют следующие возможности по
ведению версий:
- Работа с локальным и удаленным репозиторием: клонирование, фиксация
изменений, загрузка и скачивание изменений.
- Версии и фиксации: создание новых версий файлов, фиксация (commit)
изменений для сохранения новой версии.
- Ветки и работа с ними: создание отдельных веток для разработки
параллельных версий проекта, переключение между ветками.
- Слияния и разрешение конфликтов: объединение изменений из разных
веток или разных участников проекта, разрешение конфликтов при
одновременных изменениях.
- Варианты отката изменений: откат до предыдущей версии файла или ветки
проекта.
- Теги и комментирование: маркировка важных версий с помощью тегов,
добавление комментариев к фиксациям.
- Просмотр истории изменений: просмотр предыдущих версий файлов,
истории фиксаций, авторов изменений и комментариев
10) Способ хранения данных в системе Git. Способ отслеживания
целостности данных.
В системе Git данные хранятся в виде снимков (snapshots), которые
представляют собой полные копии проекта на каждый момент фиксации
(commit). Git использует структуру, называемую деревом (tree), которая

содержит указатели на файлы и поддиректории, а также хэши для контроля
целостности данных. Отслеживание целостности данных в Git
осуществляется с помощью хэш-сумм (SHA-1), которые вычисляются на
основе содержимого файлов и метаданных. Это позволяет обнаруживать
изменения и повреждения данных в репозитории.
11) Состояния файлов в СКВ Git.
В СКВ Git файлы могут находиться в следующих состояниях:
- Modified (изменен): файл был изменен, но еще не был зафиксирован (commit).
- Staged (подготовлен): изменения файла были отмечены для включения в
следующий коммит.
- Committed (зафиксирован): изменения файла были сохранены в локальной базе
данных репозитория.
12) Описание каталогов в СКВ Git.
В Git каталоги называются дерикториями (directories). Каталоги в СКВ Git
являются элементами дерева (tree) и содержат в себе файлы и другие каталоги.
Каталоги отслеживаются Git, и при коммитах сохраняется их структура и
состояние.
13) Реализация ветвления в Git. Использование ветки master.
Указатель HEAD.
Ветвление в Git реализуется с помощью создания отдельных веток, которые
представляют собой независимые линии разработки. Ветка master - это
основная ветка проекта, которая обычно считается стабильной и содержит
последнюю стабильную версию проекта. Указатель HEAD указывает на
текущую ветку, с которой происходит работа. HEAD может указывать на
ветку master или на другую ветку в случае переключения
14) Долгоживущие и тематические ветки. Удаленные ветки.
В Git существуют долгоживущие ветки (long-lived branches), такие как ветка
master, которые представляют основные линии разработки проекта.
Тематические ветки (topic branches) создаются для выполнения конкретной
задачи или разработки определенной функциональности и обычно существуют
только в течение определенного периода времени. Удаленные ветки (remote
branches) - это ветки, которые существуют в удаленном репозитории и
используются для совместной работы с другими разработчиками
15) Перемещение веток. Опишите процесс слияния (merge) веток.
Перемещение веток в Git осуществляется с помощью операции слияния (merge).
Процесс слияния объединяет изменения из одной ветки в другую. При слиянии
Git автоматически объединяет изменения, если они не конфликтуют. Если
возникают конфликты, требуется ручное разрешение. После слияния ветки Git

сохраняет историю изменений и объединяет обе ветки.
16) Перемещение веток. Опишите процесс слияния (rebase) веток.
В Git также существует процесс слияния веток, называемый rebase. При ребейзе
изменения текущей ветки применяются на основе последнего коммита другой
ветки. Это позволяет создать более линейную и

чистую историю изменений. Однако ребейз может привести к изменению
истории коммитов и созданию новых коммитов с другими хэш-суммами.
17) Разница между интерпретируемыми и компилируемыми языками
программирования. Компиляция интерпретирующего типа.
Интерпретируемые языки программирования выполняются путем
интерпретации исходного кода программы на ходу, без предварительной
компиляции в машинный код. Компилируемые языки программирования
требуют предварительной компиляции исходного кода в машинный код,
который может быть непосредственно исполнен компьютером.

18) Понятие сборки программного обеспечения. Процессы, входящие
в сборку ПО.
Сборка программного обеспечения - это процесс преобразования исходного
кода программы в исполняемые файлы или библиотеки, готовые для
выполнения на целевой платформе. Включает в себя такие процессы, как
компиляция, линковка, упаковка и развертывание. Он также может включать
выполнение тестов, оптимизацию и управление зависимостями.
19) Утилита make – задачи, описание. Содержимое make – файлов.
Утилита make используется для автоматизации процесса сборки программного
обеспечения. Make-файлы содержат инструкции и зависимости для компиляции
и сборки программы. Утилита make позволяет определить цели (target), задать
правила для их выполнения и автоматически определить, какие файлы должны
быть перекомпилированы на основе их зависимостей.
20) Стандартные цели для сборки дистрибутивов GNU.
Стандартные цели для сборки дистрибутивов GNU включают цели, такие как
"all" (сборка всех компонентов), "install" (установка программы), "clean"
(очистка сгенерированных файлов), "dist" (создание дистрибутива программы),
"distclean" (очистка сгенерированных файлов и дистрибутивов) и другие. Эти
цели определены в стандартных правилах make-файлов GNU и облегчают
процесс сборки и распространения программного обеспечения.
21) Определение автоматизации сборки. Действия, которые включает
в себя систем автоматизации.
Автоматизация сборки - это процесс использования инструментов и систем,
которые автоматически выполняют действия, связанные с компиляцией,
сборкой и развертыванием программного обеспечения. Это включает в себя
автоматическое выполнение задач, таких как компиляция исходного кода,
линковка, копирование файлов, создание исполняемых файлов или пакетов,
запуск тестов и другие действия.
22) Виды автоматизации, применяемые в различных инструментах
Виды автоматизации, применяемые в различных инструментах, включают:
- Системы сборки (build systems): например, GNU Make, Apache Ant, Gradle. Они
автоматизируют процесс компиляции и сборки программного обеспечения.
- Системы непрерывной интеграции и непрерывной доставки (CI/CD): например,
Jenkins, Travis CI, GitLab CI/CD. Они автоматизируют процессы сборки,
тестирования и развертывания программного обеспечения при каждом
изменении в репозитории.
- Конфигурационные инструменты: например, Ansible, Puppet, Chef. Они

автоматизируют установку и настройку окружения и зависимостей
программного обеспечения.
- Системы управления контейнерами: например, Docker, Kubernetes. Они
автоматизируют развертывание и управление контейнеризированными
приложениями.
23) Система сборки Gradle. Назначение, область применения, аналоги
Gradle, достоинства и недостатки Gradle. Сравнение с аналогами.
Gradle - это система сборки, которая обеспечивает гибкость и мощные
возможности для автоматизации сборки и управления зависимостями. Он
используется в основном для сборки Java-проектов, но также поддерживает
другие языки программирования. Gradle имеет DSL (Domain-Specific Language),
основанный на Groovy или Kotlin, что делает его конфигурацию и
использование более выразительными и гибкими
Преимущества Gradle:
- Гибкость и удобство использования.
- Мощная система управления зависимостями.
- Поддержка множества языков программирования.
- Возможность написания собственных плагинов.
Недостатки Gradle:
- Изучение Gradle может потребовать времени из-за его сложности.
- Некоторые операции могут занимать больше времени, чем в других системах
сборки.
Аналогами Gradle являются Apache Maven и Apache Ant, которые также
являются популярными инструментами автоматизации сборки.
24) Стандартные задачи системы сборки
Стандартные задачи системы сборки включают:
- Компиляция исходного кода.
- Линковка объектных файлов в исполняемый файл или библиотеку.
- Копирование файлов в нужное место или упаковка в дистрибутив.
- Выполнение автоматических тестов.
- Очистка (удаление временных файлов или объектных файлов).
- Установка (копирование собранных файлов в целевую систему).

25) Фазы сборки программного обеспечения
Фазы сборки программного обеспечения обычно включают:
- Подготовка: получение исходного кода, загрузка зависимостей.
- Компиляция: преобразование исходного кода в объектные файлы или
промежуточный код.
- Линковка: объединение объектных файлов или промежуточного кода в
исполняемый файл или библиотеку.
- Тестирование: выполнение автоматических тестов для проверки
работоспособности программы.
- Упаковка: создание дистрибутива, установка программы в нужную среду
выполнения.
26) Понятие жизненного цикла программного обеспечения. Модели
жизненного цикла программного обеспечения
Жизненный цикл программного обеспечения (ЖЦ ПО) - это
последовательность этапов и процессов, через которые проходит программное
обеспечение от момента его создания и разработки до вывода из эксплуатации.
ЖЦ ПО включает в себя фазы, такие как анализ и планирование, разработка,
тестирование, развертывание и поддержка. Каждая фаза имеет свои цели,
задачи и результаты, которые влияют на следующую фазу
27) Определение каскадной модели жизненного цикла. Ее
преимущества и недостатки. Область применения.
Каскадная модель жизненного цикла (Waterfall model) - это классическая
модель, в которой разработка ПО происходит последовательно и линейно,
переходя от одной фазы к другой: анализ, проектирование, реализация,
тестирование и сопровождение. Преимущества каскадной модели включают
простоту понимания, четкую структуру и возможность документирования
каждой фазы. Однако у нее есть недостатки, такие как ограниченная гибкость
при изменениях требований и трудности возврата к предыдущим фазам.
28) Определение инкрементной модели жизненного цикла. Ее
преимущества и недостатки. Область применения.
Инкрементная модель жизненного цикла (Incremental model) - это модель, в
которой разработка ПО разбивается на набор инкрементов, где каждый
инкремент представляет собой улучшение или расширение

функциональности. Преимущества инкрементной модели включают более
гибкий подход к разработке, возможность быстрого предоставления частей
продукта и лучшую адаптацию к изменениям требований. Недостатки
включают сложность управления множеством инкрементов и потенциальные
проблемы с интеграцией и тестированием.
29) Определение V модели жизненного цикла. Ее преимущества и
недостатки. Область применения.
V модель жизненного цикла (V-model) - это модель, которая связывает
каждую фазу разработки ПО с соответствующей фазой тестирования. Фазы
разработки включают анализ требований, спецификацию, проектирование,
реализацию, интеграцию и тестирование, а затем происходит обратный
процесс тестирования, включая модульное тестирование, интеграционное
тестирование, системное тестирование и приемочное тестирование.
Преимущества V-модели включают усиленное взаимодействие между
разработкой и тестированием, раннее обнаружение дефектов и улучшенное
планирование тестирования. Недостатки V-модели включают ее жесткую и
последовательную структуру, которая может затруднить изменения
требований.
30) Определение модели жизненного цикла на основе прототипа. Ее
преимущества и недостатки. Область применения.
Модель жизненного цикла на основе прототипа (Prototype model) - это модель,
в которой создается прототип (примерный вариант) программного продукта
для обратной связи с заказчиком и получения обратной информации.
Преимущества модели на основе прототипа включают более точное
определение требований, улучшенную взаимодействие с заказчиком,
возможность быстрого получения обратной связи и улучшение качества
конечного продукта. Недостатки включают риск недостаточной
структурированности, затраты на создание прототипа и возможные сложности
в поддержке и поддержке прототипа. Область применения модели на основе
прототипа включает ситуации, когда требования неясны или изменчивы, а
также для создания интерфейсов пользователя или сложных систем.
31) Определение спиральной модели жизненного цикла. Ее

преимущества и недостатки. Область применения.
Спиральная модель жизненного цикла (Spiral model) - это модель, которая
объединяет итеративные и инкрементные подходы с анализом рисков. Она
состоит из последовательности циклов, в каждом из которых выполняются
этапы определения целей, анализа рисков, разработки, оценки и
планирования. Преимущества спиральной модели включают учет рисков и
возможность их предотвращения, гибкость и возможность постепенного
улучшения продукта. Недостатки включают сложность и потенциальную
необходимость в больших временных и финансовых затратах. Область
применения спиральной модели включает проекты с высокими рисками и
сложностями, где важна оценка и управление рисками.
32) Документирование знаний при разработке программного
обеспечения. Системы Confluence, MediaWiki.
Документирование знаний при разработке программного обеспечения - это
процесс создания и поддержки документации, которая описывает
архитектуру, функциональность, процессы и другие аспекты программного
обеспечения. Системы Confluence и MediaWiki являются инструментами для
управления и совместной работы над документацией и знаниями в разработке
программного обеспечения. Confluence предоставляет возможность создания
структурированных страниц, обмена информацией и комментирования, а

MediaWiki предоставляет возможность создания и редактирования вики-
страниц.

33) Понятие концепции CI/CD.
Концепция CI/CD (Continuous Integration/Continuous Deployment) - это практика
разработки программного обеспечения, которая объединяет непрерывную
интеграцию изменений в коде и непрерывное развертывание приложения в
производственную среду. Она основана на автоматизации процессов сборки,
тестирования и развертывания, чтобы обеспечить быструю и надежную
доставку изменений.
34) Основные принципы CI/CD.
Основные принципы CI/CD включают:
- Непрерывная интеграция: интеграция изменений в основную ветку разработки
на регулярной основе.
- Непрерывная доставка: автоматическое создание исполняемых компонентов и
их готовность для развертывания в любой момент.

- Непрерывное развертывание: автоматическое развертывание изменений в
производственную среду после успешного прохождения всех тестов
35) Организация управления требованиями в CI/CD
Управление требованиями в CI/CD включает

определение и документирование требований, их отслеживание и управление
изменениями. Оно может включать использование систем отслеживания ошибок
и требований, коммуникацию и согласование между разработчиками и
заинтересованными сторонами, а также автоматизацию процессов обновления и
отслеживания требований.
36) Конвейер развертывания. Основные этапы и задачи. Настройка
конвейера развертывания.
Конвейер развертывания (Deployment pipeline) - это последовательность этапов
и задач, которые выполняются для развертывания приложения от исходного
кода до его развертывания в производственную среду. Основные этапы
включают сборку, тестирование, упаковку, развертывание и автоматическую
проверку. Настройка конвейера развертывания включает определение этапов,
конфигурацию инструментов автоматизации, определение условий и действий
для перехода между этапами.
37) Понятие среды окружения. Объекты среды окружения.
Среда окружения (Environment) - это набор параметров и ресурсов, в которых
выполняется приложение. Объекты среды окружения могут включать серверы,
базы данных, сетевые ресурсы, настройки конфигурации и другие компоненты,
необходимые для функционирования приложения.
38) Основные переменные среды окружения ОС Linux.
Основные переменные среды окружения ОС Linux включают:
- PATH: переменная, содержащая список путей к исполняемым файлам.
- HOME: переменная, содержащая домашний каталог пользователя.
- USER: переменная, содержащая имя текущего пользователя.
- SHELL: переменная, содержащая путь к интерпретатору командной строки.
- LANG: переменная, определяющая текущую языковую локаль.

39) Понятие системного окружения (яруса) в концепции методологии
CI/CD.
Системное окружение (ярус) в концепции методологии CI/CD представляет
собой набор компонентов и настроек, которые обеспечивают исполнение и
развертывание приложения в определенной среде. Он может включать
операционную систему, серверное программное обеспечение, конфигурацию
сети, базы данных и другие компоненты, необходимые для запуска
приложения.
40) Архитектуры сред окружения. Основные понятия, назначение,
решаемые задачи.
Архитектуры сред окружения - это структуры и компоненты, которые
обеспечивают функционирование и управление средой окружения. Основные
понятия включают:
- Оркестраторы контейнеров: инструменты, которые управляют и
развертывают контейнеризованные приложения, такие как Kubernetes и Docker

Swarm.
- Оркестраторы сервисов: инструменты, которые управляют и развертывают
микросервисы и их взаимодействие, такие как Consul и Istio.
- Конфигурационные менеджеры: инструменты, которые управляют и хранят
конфигурацию и параметры среды, такие как Ansible и Chef.
- Инфраструктура как код: подход, который позволяет определять
инфраструктуру с использованием кода, такой как Terraform и CloudFormation.

Архитектуры сред окружения решают задачи автоматизации и управления
инфраструктурой, обеспечивают гибкость, масштабируемость и надежность
при развертывании и выполнении приложений.
41) Определение понятия «виртуализация». Задачи виртуализации.
Типы виртуализации.
Виртуализация - это технология, которая позволяет создавать виртуальные
экземпляры ресурсов (например, операционных систем, серверов, сетей,

хранилищ), изолированные и независимые друг от друга, на одном физическом
компьютере или в вычислительной среде. Основные задачи виртуализации
включают:
- Максимизацию использования аппаратных ресурсов: возможность
эффективного использования ресурсов, таких как процессорное время, память,
хранилище, сеть.
- Изоляция и безопасность: обеспечение независимости и безопасности
виртуальных экземпляров, так чтобы изменения в одном экземпляре не влияли
на другие.
- Упрощение развертывания и управления: возможность создания,
конфигурации, миграции и масштабирования виртуальных экземпляров.
- Обеспечение высокой доступности и отказоустойчивости: возможность
обеспечить непрерывную работу и быстрое восстановление в случае сбоев.

Типы виртуализации:
- Виртуализация на уровне операционной системы (контейнеризация).
- Виртуализация на уровне приложения.
- Полная (аппаратная) виртуализация.
- Виртуализация сети.
- Виртуализация хранилища.
42) Определение понятия «виртуализация». Преимущества
виртуализации.
Преимущества виртуализации включают:
- Максимизацию использования аппаратных ресурсов.
- Изоляцию и безопасность виртуальных экземпляров.
- Упрощение развертывания и управления.
- Возможность масштабирования и гибкого управления ресурсами.
- Увеличение доступности и отказоустойчивости.
- Снижение затрат на оборудование и энергопотребление.
43) Определение понятия «виртуализация». Недостатки
виртуализации.
Недостатки виртуализации могут включать:

- Потерю производительности из-за накладных расходов виртуализационного
слоя.
- Возможные проблемы совместимости или конфликты ресурсов между
виртуальными экземплярами.
- Дополнительные сложности в настройке и управлении виртуализацией.
- Ограничения, связанные с аппаратной совместимостью и возможностями
виртуализационных технологий.
44) Виртуализация операционной системы. Задачи, применение.
Виртуализация операционной системы - это тип вир
туализации, при котором на одном физическом компьютере может быть
запущено несколько изолированных экземпляров операционных систем. Задачи
виртуализации операционной системы включают обеспечение разделения
ресурсов, изоляцию окружений, управление и мониторинг экземпляров
операционной системы. Применение включает серверную виртуализацию,
создание тестовых окружений, разработку и тестирование программного
обеспечения.
45) Виртуализация серверов приложений. Задачи, применение.
Виртуализация серверов приложений позволяет создавать виртуальные
экземпляры серверов приложений на одном физическом сервере. Задачи
включают масштабирование приложений, обеспечение высокой доступности,
разделение ресурсов и управление различными версиями серверов приложений.
Применение включает хостинговые услуги, облачные платформы, тестирование
и разработку приложений.
46) Виртуализация сети. Задачи, применение.
Виртуализация сети позволяет создавать виртуальные сетевые ресурсы и
сетевые топологии. Задачи включают разделение сетевого трафика,
маршрутизацию, изоляцию сетевых сегментов и управление сетевыми
политиками. Применение включает облачные сети, виртуальные частные сети
(VPN), сетевые тестовые среды.
47) Виртуализация аппаратного обеспечения. Задачи, применение.
Виртуализация аппаратного обеспечения (Hypervisor-based виртуализация)
позволяет создавать виртуальные экземпляры физического оборудования, таких
как процессоры, память и периферийные устройства. Задачи включают создание
виртуальных машин с независимыми операционными системами, управление
ресурсами и изоляцию виртуальных экземпляров. Применение включает
серверную виртуализацию, консолидацию серверов, тестирование и разработку
программного обеспечения.
48) Виртуализация систем хранения. Задачи, применение.
Виртуализация систем хранения позволяет объединять и управлять

физическими хранилищами данных в виде виртуальных ресурсов. Задачи
включают абстрагирование и объединение хранилищ, управление доступом к
данным, резервное копирование и восстановление данных. Применение
включает хранилища данных на основе виртуализации (Storage Area Network -
SAN), виртуальные диски, хранилища в облаке.
49) Виртуализация сервисов. Задачи, применение.
Виртуализация сервисов позволяет предоставлять виртуальные экземпляры
служб и приложений. Задачи включают предоставление сервисов как облачных
услуг (IaaS, PaaS, SaaS), масштабирование и управление службами, изоляцию и
безопасность служб. Применение включает облачные платформы, виртуальные
рабочие места (VDI), предоставление приложений как службы.
50) Решения виртуализации. Примеры решений виртуализации

Примеры решений виртуализации включают VMware vSphere, Microsoft Hyper-
V, Citrix XenServer, KVM, Docker, OpenStack и AWS (Amazon Web Services)

EC2.
51) Программная виртуализация. Задачи программной виртуализации.
Преимущества и недостатки программной виртуализации. Приведите
примеры программной виртуализации.
Программная виртуализация - это технология, которая позволяет запускать
виртуальные экземпляры программного обеспечения на одном физическом
компьютере или в вычислительной среде. Задачи программной виртуализации
включают изоляцию приложений, эффективное использование ресурсов,
упрощенное развертывание и управление приложениями. Преимущества
программной виртуализации включают гибкость, масштабируемость,
управляемость и снижение затрат. Примеры программной виртуализации
включают виртуальные машины (Virtual Machines - VM), контейнеры
(например, Docker), виртуальные среды разработки (Virtual Development
Environments).
52) Виртуализация ИТ-инфраструктуры. Задачи, преимущества и
недостатки виртуализация ИТ-инфраструктуры, область ее применения.
Виртуализация ИТ-инфраструктуры - это процесс создания виртуальной
версии физической инфраструктуры, такой как серверы, сети, хранилища
данных и другие ресурсы. Задачи виртуализации ИТ-инфраструктуры
включают консолидацию ресурсов, оптимизацию использования
аппаратного обеспечения, обеспечение высокой доступности, управление

и мониторинг инфраструктуры. Преимущества включают более
эффективное использование ресурсов, сокращение затрат на
оборудование и энергию, лучшую масштабируемость и упрощенное
управление. Недостатки могут включать повышенную сложность
конфигурации и настройки, потерю производительности из-за
виртуализации и потенциальные проблемы безопасности. Виртуализация
ИТ-инфраструктуры применяется в центрах обработки данных, облачных
платформах, виртуальных сетях и других вычислительных средах.
53) Контейнерная виртуализация. Задачи, применение.
Контейнерная виртуализация - это методология виртуализации, при которой
приложения и их зависимости упаковываются в изолированные контейнеры.
Задачи контейнерной виртуализации включают разделение и изоляцию
приложений, обеспечение переносимости и повторяемости развертывания,
упрощение разработки и масштабирования приложений. Применение
контейнерной виртуализации включает развертывание микросервисных
архитектур, сборку и доставку приложений, тестирование и разработку
программного обеспечения.
54) Применение контейнеризации в современных вычислительных
системах.
Контейнеризация широко применяется в современных вычислительных
системах для упаковки, развертывания и управления приложениями. Она
позволяет упаковывать приложения и их зависимости в контейнеры, которые
могут быть легко перенесены между различными средами выполнения, такими
как различные операционные системы или облачные платформы. Контейнеры
обеспечивают изоляцию и безопасность приложений, а также позволяют
эффективно использовать ресурсы и упрощают управление и развертывание
приложений.
55) Контейнеры приложений.
Контейнеры приложений - это изолированные среды, в которых упакованы
приложения и все их зависимости. Контейнеры приложений содержат все
необходимое для выполнения приложения, включая исполняемый код,
библиотеки, настройки и файлы данных. Контейнеры приложений обеспечивают
консистентную среду выполнения для приложений и гарантируют их
переносимость и повторяемость в различных средах.
56) Классификация контейнеров. Терминология Linux контейнеров
Классификация контейнеров включает два основных типа: системные
контейнеры и контейнеры приложений. Системные контейнеры обеспечивают

изолированное окружение для запуска операционной системы и приложений.
Контейнеры приложений, такие как Docker контейнеры, упаковывают только
приложения и их зависимости, работая поверх общей операционной системы.
57) Оркестрация контейнеров. Цели и задачи.
Оркестрация контейнеров - это процесс управления и координации
развертывания и управления множеством контейнеров. Цели оркестрации
контейнеров включают автоматическое масштабирование, обнаружение и
восстановление сбоев, балансировку нагрузки и управление сетевыми связями.
Оркестрация контейнеров позволяет эффективно использовать ресурсы и
облегчает управление сложными микросервисными архитектурами.
58) Образ контейнера. Определение. Два состояния контейнера.
Образ контейнера - это файловая система, которая содержит все необходимое
для выполнения приложения в контейнере. Образ контейнера может включать
исполняемый код, библиотеки, настройки, зависимости и другие файлы,
необходимые для работы приложения. Два состояния контейнера включают
базовый образ, который содержит минимально необходимое для выполнения
приложения, и изменения, которые могут быть применены поверх базового
образа для настройки и настройки приложения.
59) Контейнерный движок. Задачи контейнерного движка.
Контейнерный движок - это программное обеспечение, которое отвечает за
создание и управление контейнерами. Задачи контейнерного движка включают
изоляцию контейнеров, управление жизненным циклом контейнеров,
развертывание и удаление контейнеров, управление ресурсами и безопасностью.
Примером контейнерного движка является Docker.
60) Контейнерный хост. Определение. Задачи.
Контейнерный хост - это физический или виртуальный компьютер, на котором
работает контейнерный движок и на котором запускаются контейнеры.
Контейнерный хост предоставляет ресурсы и окружение для работы
контейнеров, включая процессор, память, хранилище и сетевые ресурсы.
61) Сервер реестра. Определение. Задачи.

Сервер реестра - это сервер, который служит для хранения и распространения
контейнерных образов. Сервер реестра предоставляет централизованное
хранилище образов и обеспечивает доступ к ним для развертывания и
использования контейнеров.

62) Определение системы докер. Докер-демон и докер – клиент.
Система Docker - это платформа для автоматизации развертывания, упаковки и
управления контейнерами. Docker включает в себя две основные компоненты:
Docker-демон, который управляет контейнерами и реализует контейнерную
виртуализацию, и Docker-клиент, который предоставляет интерфейс командной
строки и API для взаимодействия с Docker-демоном.
63) Определение системы докер. Докер-образ и докер – реестр.
В системе Docker образ контейнера - это снимок файловой системы и настроек,
необходимых для работы приложения в контейнере. Docker-реестр - это
репозиторий, в котором хранятся Docker-образы. Реестр позволяет
распространять, обмениваться и загружать Docker-образы для развертывания и
использования контейнеров.
64) Пространство имен в системе докер. Основные пространства имен.
Пространства имен (namespaces) в системе Docker - это механизм изоляции,
который позволяет контейнерам иметь собственное изолированное окружение,
включая процессы, сетевые ресурсы, файловые системы и другие системные
ресурсы. Основные пространства имен в Docker включают пространства имен
процессов, сети, монтирования файловой системы и пользователя.
65) Конфигурационное управление. Цели и задачи
конфигурационного управления.
Конфигурационное управление в контексте виртуализации и контейнеризации
включает управление настройками и параметрами конфигурации виртуальных
машин или контейнеров. Цели конфигурационного управления включают
автоматизацию процесса развертывания, обеспечение консистентности
конфигурации и облегчение масштабирования и обслуживания систем.
Конфигурационное управление может включать использование инструментов
и систем, таких как Ansible, Puppet, Chef и Terraform, для управления
конфигурацией и развертыванием виртуальных сред и контейнеров.
66) Конфигурационное управление. Процедуры управления
конфигурацией.
Конфигурационное управление (Configuration Management) - это процесс
управления и контроля конфигурацией программного обеспечения, включая
его компоненты, настройки, зависимости и версии. Процедуры управления
конфигурацией включают идентификацию, контроль, аудит, учет и управление
изменениями в конфигурации программного продукта. Это позволяет
обеспечить целостность и стабильность программного обеспечения в течение

его жизненного цикла.
67) Методология DevOps. Основные положения.
Методология DevOps объединяет разработку (Development) и операции
(Operations) в единую практику для обеспечения непрерывной разработки,
доставки и обслуживания программного обеспечения. Основные положения
DevOps включают автоматизацию процессов, совместную ответственность
разработчиков и операционных команд, непрерывное тестирование и обратную
связь, использование инструментов и практик для повышения скорости и
качества разработки.
68) Непрерывная доставка. Определение. Основные элементы.
Непрерывная доставка (Continuous Delivery) - это практика автоматического
выпуска программного обеспечения в производственную среду с минимальным
ручным вмешательством. Основными элементами непрерывной доставки
являются автоматизация сборки, тестирования и развертывания программного
обеспечения, создание надежной инфраструктуры доставки и управление
конфигурациями для обеспечения повторяемости и безопасности процесса
доставки.
69) Непрерывная интеграция. Определение. Основные элементы.
Непрерывная интеграция (Continuous Integration) - это практика интеграции
изменений в код программного обеспечения от разных разработчиков в общую
кодовую базу на регулярной основе. Основными элементами непрерывной
интеграции являются автоматизированная сборка и тестирование кода, частая
интеграция изменений, обеспечение согласованности и работоспособности
кодовой базы.
70) Основы микросервисной архитектуры. Определение. Принципы
проектирования.
Микросервисная архитектура - это подход к разработке программного
обеспечения, при котором приложение разбивается на небольшие, слабо
связанные и независимо развертываемые сервисы, которые взаимодействуют
друг с другом через API. Основные принципы микросервисной архитектуры
включают изоляцию сервисов, расширяемость, независимость развертывания и
гибкость в выборе технологий для каждого сервиса.
71) Основы микросервисной архитектуры. Определение.
Преимущества и недостатки.
Микросервисная архитектура обладает следующими преимуществами:
легкость масштабирования, улучшенная отказоустойчивость, независимость
разработки и развертывания сервисов, возможность использования разных
технологий и языков программирования для разных сервисов. Однако у нее

также есть недостатки, такие как увеличенная сложность управления и отладки,
увеличенные требования к коммуникации между сервисами и необходимость
обеспечения согласованности данных.
72) Технология разработки программного обеспечения. Основные
понятия, область применения. Отличие технологии разработки программного
обеспечения от программной инженерии.
Технология разработки программного обеспечения - это набор методов,
инструментов и подходов, используемых для создания, тестирования,
развертывания и обслуживания программного обеспечения. Она охватывает все
этапы жизненного цикла разработки программного обеспечения, включая
анализ требований, проектирование, кодирование, тестирование,
развертывание и сопровождение.
73) Фаза разработки программных приложений. Этапы фазы
разработки программного обеспечения.
Фазы разработки программного обеспечения включают следующие этапы:
анализ требований, проектирование, реализация, тестирование, развертывание
и сопровождение. Каждая фаза имеет свои задачи, цели и результаты, и они
последовательно выполняются в ходе разработки программного продукта.
74) Коллективная разработка программных приложений.
Особенности коллективной разработки.
Коллективная разработка программных приложений - это процесс разработки
программного обеспечения, в котором несколько разработчиков совместно
работают над проектом. Особенности коллективной разработки включают
использование систем контроля версий, распределение задач между
разработчиками, обмен знаниями и опытом, совместное тестирование и
обратную связь.
75) Основные правила оформления программного кода. Приведите
примеры правильного и неправильного оформления кода.
Основные правила оформления программного кода включают использование
понятных и описательных имен переменных и функций, отступы и
форматирование для обеспечения читаемости, комментирование кода для
объяснения сложных частей и соблюдение стандартов кодирования,

установленных для проекта или языка программирования. Примеры
правильного оформления кода включают использование согласованных стилей
и форматирования, а неправильное оформление может быть связано с
непонятными именами переменных, неправильным выравниванием или
отсутствием комментариев.
76) Рефакторинг программного кода. Масштабируемый рефакторинг
программного кода. Основные цели, задачи и приемы рефакторинга.
Рефакторинг программного кода - это процесс изменения кода с целью
улучшения его структуры, поддерживаемости и производительности без
изменения его внешнего поведения. Масштабируемый рефакторинг
программного кода относится к применению рефакторинга на больших
проектах или с распределенной командой разработчиков. Основные цели
рефакторинга включают устранение дублирования кода, улучшение
модульности и повторного использования, улучшение читаемости и
понимаемости кода. Для рефакторинга могут использоваться такие приемы, как
извлечение метода, переименование переменных, выделение классов и т.д.
77) Комментирование программного кода. Основные правила
комментирования.
Комментирование программного кода включает использование комментариев
для пояснения сложных алгоритмов, описания назначения и особенностей кода,
а также для оставления заметок и указания на потенциальные проблемы или
улучшения. Основные правила комментирования кода включают
использование ясного и понятного языка, комментирование только тех мест, где
это действительно необходимо, избегание очевидных или ненужных
комментариев и регулярное обновление комментариев вместе с изменениями
кода.
78) Комментирование объектов баз данных, предназначенных для
хранения данных. Основные правила их комментирования.
Комментирование объектов баз данных, предназначенных для хранения
данных, включает использование комментариев для описания структуры
таблиц, полей, связей и правил хранения данных. Основные правила
комментирования объектов баз данных включают использование

информативных и описательных комментариев, добавление комментариев к
сложным или неочевидным частям структуры базы данных, а также
поддержание комментариев в актуальном состоянии при внесении изменений в
базу данных.
79) Современные сервисы для организации коллективной разработки
программных приложений. Приведите примеры подобных сервисов.
Современные сервисы для организации коллективной разработки программных
приложений включают такие платформы, как GitHub, GitLab, Bitbucket и Azure
DevOps. Эти сервисы предоставляют функциональность систем контроля
версий, возможность совместной работы над проектами, управление задачами
и заданиями, интеграцию с инструментами автоматизации и непрерывной
интеграции.

80) Понятие версии программного продукта и системы контроля
версий. Модели версионирования и их сравнение.
Версия программного продукта - это идентификатор, используемый для
отслеживания и управления изменениями программного обеспечения. Система
контроля версий (Version Control System) позволяет управлять и контролировать
версии программного продукта. Модели версионирования могут включать
числовые обозначения (например, 1.0, 1.1, 2.0), семантическое версионирование
(например, MAJOR.MINOR.PATCH), дата-ориентированные версии и другие.
Каждая модель имеет свои преимущества и выбирается в зависимости от
требований и практик разработчиков.
81) Последовательность и состав действий при работе с локальным и
удаленным хранилищем системы контроля версий.
При работе с локальным и удаленным хранилищем системы контроля версий
(СКВ) обычно выполняются следующие действия:

1. Клонирование (checkout): Создание локальной копии репозитория из
удаленного хранилища. Это позволяет получить полную историю версий и
файлов проекта.

2. Работа с файлами: Внесение изменений в файлы проекта в локальной копии.
Это может включать создание, изменение или удаление файлов и директорий.

3. Обновление (update): Получение последних изменений из удаленного
хранилища и слияние их с локальными изменениями. Это позволяет быть в
курсе последних обновлений проекта и внести свои изменения на основе
актуальной версии.

4. Фиксация (commit): Зафиксировать локальные изменения и создать новую
версию в локальном репозитории. Коммиты содержат описание изменений и
уникальный идентификатор.

5. Загрузка (push): Отправка коммитов из локального репозитория в удаленное

хранилище. Таким образом, изменения становятся доступными другим
разработчикам.

6. Получение (pull): Получение новых коммитов из удаленного хранилища и
слияние их с локальным репозиторием. Это необходимо, если другие
разработчики внесли изменения, которые нужно включить в свою локальную
копию.
82) Система Subversion и ее архитектура. Хранилище системы, его
структура, правки. Сценарий объединения правок. Конфликты и способы их
разрешения.
Система Subversion (SVN) - это система контроля версий, которая позволяет
управлять и отслеживать изменения в файловой системе. Её архитектура
состоит из трех основных компонентов:

- Репозиторий (Repository): Центральное хранилище, где хранятся все версии
файлов проекта. Репозиторий обычно размещается на удаленном сервере и
доступен для синхронизации с локальными копиями.

- Рабочая копия (Working Copy): Локальная копия проекта, которая содержит
файлы и историю версий. Разработчики работают с рабочей копией, внося
изменения и выполняя операции контроля версий.

- Клиент (Client): Программа, которая предоставляет интерфейс для
взаимодействия с репозиторием и управления рабочей копией. Клиенты SVN
доступны для различных операционных систем и

интегрируются с средами разработки.

Правки в SVN выполняются следующим образом:
1. Получение рабочей копии проекта с помощью команды "checkout".
2. Внесение изменений в файлы проекта, добавление новых файлов или
удаление существующих.

3. Фиксация изменений с помощью команды "commit", которая создает новую
версию в репозитории и сохраняет изменения.

При объединении правок может возникнуть конфликт, когда два или более
разработчиков внесли изменения в одну и ту же часть файла. Для разрешения
конфликта разработчики должны вручную выбрать, какие изменения следует
сохранить и какие отклонить. SVN предоставляет инструменты для разрешения
конфликтов, позволяющие сравнивать изменения и выбирать нужные
варианты.
83) Пакеты и менеджеры пакетов ОС Linux. Основные понятия,
состав, назначение, решаемые задачи. Приведите примеры пакетов и
менеджеров пакетов
В операционной системе Linux пакеты представляют собой архивы,
содержащие исполняемые файлы, библиотеки, настройки и другие компоненты
программного обеспечения. Пакеты облегчают установку, обновление и
удаление программ на Linux.

Менеджеры пакетов - это инструменты, которые обеспечивают управление
пакетами в системе. Они позволяют искать, устанавливать, обновлять и удалять
пакеты, а также управлять зависимостями между пакетами.

Примеры популярных менеджеров пакетов в Linux:
- Advanced Package Tool (APT) - используется в дистрибутивах Debian и Ubuntu.
- Yellowdog Updater, Modified (YUM) - используется в дистрибутивах Red Hat,
CentOS и Fedora.
- Zypper - используется в дистрибутиве openSUSE.
- Pacman - используется в дистрибутиве Arch Linux.
- DNF (Dandified YUM) - используется в дистрибутиве Fedora (начиная с версии
22).
84) Зависимости пакетов и управление зависимостями менеджерами
пакетов. Основные понятия, назначение, решаемые задачи. Приведите
примеры управлениями зависимостями.

Зависимости пакетов - это отношения между пакетами, когда один пакет
требует наличия другого пакета для своей работы. Управление зависимостями
в менеджерах пакетов позволяет автоматически устанавливать требуемые
пакеты и их версии при установке или обновлении программного обеспечения.

Основные понятия и решаемые задачи управления зависимостями:
- Зависимость "зависимость-от" (dependency): Указывает, какие пакеты
требуются для работы данного пакета.
- Зависимость "противоречие" (conflict): Указывает, что данный пакет
несовместим с другим пакетом.
- Зависимость "замещение" (replaces): Указывает, что данный пакет заменяет
другой пакет.

Примеры управления зависимостями:
- Установка пакета и автоматическое разрешение зависимостей.
- Обновление пакета и его зависимостей до последних версий.
- Удаление пакета и автоматическое удаление связанных зависимостей, если
они больше не требуются другими пакетами.
85) Управление пакетами в ОС Linux. Приведите примеры управления
пакетами в ОС Linux.
Управление пакетами в ОС Linux включает следующие операции:

- Установка пакета: Менеджер пакетов позволяет установить выбранный пакет
из доступного репозитория с помощью команды установки.
Пример: apt install <package_name> (для APT в Debian и Ubuntu)

- Обновление пакетов: Менеджер пакетов позволяет обновить установленные
пакеты до последних версий из репозитория.
Пример: apt update (обновление списка пакетов) и apt upgrade (обновление
пакетов) (для APT в Debian и Ubuntu)

- Удаление пакета: Менеджер пакетов позволяет удалить установленный пакет с

помощью команды удаления.
Пример: apt remove <package_name> (для APT в Debian и Ubuntu)

- Поиск пакета: Менеджер пакетов позволяет искать пакеты по имени или
описанию в репозитории.
Пример: apt search <search_term> (для APT в Debian и Ubuntu)

- Отображение информации о пакете: Менеджер пакетов предоставляет
информацию о пакете, такую как версия, зависимости, описание и т. д.
Пример: apt show <package_name> (для APT в Debian и Ubuntu)
86) Непрерывная интеграция CI и экстремальное программирование.
Организация, преимущества и недостатки непрерывной интеграции.
Приведите примеры непрерывной интеграции.
Непрерывная интеграция (CI) и экстремальное программирование (XP) - это
практики разработки программного обеспечения, направленные на повышение
качества и эффективности разработки.

Непрерывная интеграция (CI) - это процесс автоматической сборки и
тестирования приложения при каждом изменении кода. Главная идея CI
заключается в том, чтобы интегрировать изменения разработчиков как можно
чаще, чтобы обнаружить и исправить ошибки и конфликты как можно раньше

. Это позволяет обеспечить стабильность кодовой базы и своевременное
выявление проблем.

Преимущества непрерывной интеграции включают:
- Быстрое выявление и исправление ошибок.
- Упрощение интеграции изменений разработчиков.
- Улучшение качества кода и процесса разработки.
- Быстрая обратная связь о состоянии сборки и тестов.

Недостатки непрерывной интеграции:

- Необходимость автоматизации сборки и тестирования.
- Зависимость от стабильности и надежности инфраструктуры CI.

Примеры непрерывной интеграции:
- Использование системы CI/CD, такой как Jenkins, Travis CI или CircleCI, для
автоматической сборки, тестирования и развертывания приложения при каждом
коммите в репозиторий.
87) Возможности GitLab CI для непрерывной интеграции. Приведите
примеры применения GitLab CI для непрерывной интеграции.
GitLab CI (Continuous Integration) - это встроенная в GitLab функциональность,
позволяющая настраивать непрерывную интеграцию для проектов. GitLab CI
использует файл конфигурации в формате YAML (.gitlab-ci.yml), где
определяются этапы сборки, тестирования и развертывания приложения.

Примеры применения GitLab CI для непрерывной интеграции:
- Автоматическая сборка приложения после каждого коммита в репозиторий.
- Выполнение различных типов тестов (юнит-тесты, интеграционные тесты,
тесты производительности) для обеспечения качества кода.
- Создание и публикация отчетов о тестировании и проверке качества кода.
- Автоматическое развертывание приложения в тестовые или продуктивные
окружения при успешной сборке и тестировании.
88) Развёртывание программного обеспечения. Основные понятия,
назначение, решаемые задачи. Приведите примеры развёртывания
программного обеспечения.
Развёртывание программного обеспечения (deployment) - это процесс установки
и настройки программного обеспечения на целевой среде выполнения, такой
как сервер или компьютер конечного пользователя. Основная цель
развёртывания - обеспечить функциональность и доступность приложения для
конечных пользователей.

Назначение развёртывания программного обеспечения:
- Установка программного обеспечения на целевую среду выполнения.

- Настройка и конфигурация приложения в соответствии с требованиями
окружения.
- Проверка работоспособности и готовности приложения к использованию.
- Развертывание обновлений и патчей для приложения.
Примеры развёртывания программного обеспечения:
- Установка и настройка веб-приложения на сервере.
- Развертывание мобильного приложения в магазине приложений для
скачивания и установки на устройства пользователей.
- Развёртывание обновлений и исправлений ошибок для рабочего приложения
в офисной сети организации.
89) Окружения развёртывания программного обеспечения. Ярусы.
Приведите примеры окружений и ярусов.
Окружения развёртывания программного обеспечения - это различные
среды, в которых происходит развёртывание приложения. Они могут
варьироваться по своей функциональности, конфигурации и доступу для
конечных пользователей. Окружения могут быть физическими или
виртуальными.

Примеры окружений развёртывания:
- Тестовое окружение (test environment): Используется для тестирования и
отладки приложения до его развёртывания в рабочей среде.
- Промежуточное окружение (staging environment): Используется для
проверки работоспособности приложения в условиях, близких к рабочей
среде.
- Продуктивное окружение (production environment): Это окружение, в
котором приложение доступно конечным пользователям для реального
использования.
- Виртуальные окружения (virtual environments): Могут быть созданы для
разработки, тестирования и демонстрации приложений в изолированной
среде.

Примеры ярусов развёртывания:

- Физический сервер (bare metal server): Физический сервер, на котором
развёртывается приложение без использования виртуализации.
- Виртуальная машина (virtual machine): Виртуализированная среда,
созданная на физическом сервере, на которой развёртывается приложение.
- Контейнер (container): Легковесная виртуализированная среда, где
приложение и его зависимости изолированы и могут работать на одном
хосте.
- Облачная среда (cloud environment): Использование вычислительных
ресурсов и сервисов облачных провайдеров для развёртывания и
масштабирования приложений.
90) Действия при развертывании программного обеспечения.
Подготовка программных приложений к развертыванию
При развертывании программного обеспечения выполняются следующие
действия:

1. Подготовка окружения: Создание необходимых серверов или виртуальных
машин, установка операционной системы и необходимого программного
обеспечения.

2. Установка и настройка приложений: Установка основных компонентов
приложения, настройка баз данных, веб-серверов, настройка сетевых
параметров и конфигураций.

3. Проверка и тестирование: Выполнение тестов для проверки
работоспособности приложения, включая тесты безопасности,
производительности и функциональности.

4. Импорт и загрузка данных: Если необходимо, можно импортировать
предварительно подготовленные данные в приложение, например, базы
данных или конфигурационные файлы.

5. Запуск и мониторинг: Запуск приложения в рабочей среде и настройка

мониторинга для отслеживания его работы и производительности.

6. Резервное копирование и обновление: Создание резервной копии
приложения и настройка процесса обновления для последующих версий.
91) Технологии и решения развертывания программного
обеспечения. Приведите примеры современных систем развертывания
программного обеспечения.
Современные системы развертывания программного обеспечения включают:

- Ansible: Инфраструктурная платформа с открытым исходным кодом, которая
позволяет автоматизировать развертывание, управление конфигурацией и
оркестрацию приложений.
- Kubernetes: Оркестрационная система контейнеров, которая обеспечивает
автоматизированное развертывание, масштабирование и управление
приложениями в контейнерах.
- Docker: Платформа для разработки, развертывания и запуска приложений в
контейнерах, обеспечивающая переносимость и изоляцию приложений.
- Puppet: Инструмент управления конфигурацией, который позволяет
автоматизировать установку и настройку приложений и инфраструктуры.
- Chef: Инфраструктурный инструмент для автоматизации развертывания и
управления конфигурацией приложений и серверов.
92) Типовые ошибки развёртывания программного обеспечения. Их
причины и проявление этих ошибок. Приведите примеры.
Типовые ошибки развёртывания программного обеспечения включают:

- Неправильная конфигурация приложения: Неправильные настройки или
параметры приложения, которые могут привести к неработоспособности или
нестабильности приложения.

- Ошибки при установке зависимостей: Неудачная установка или от

сутствие необходимых зависимостей, которые приложение требует для работы.

- Проблемы с сетью или доступом: Неправильная настройка сетевых параметров
или ограничения доступа, которые могут привести к проблемам связи или отказу
в доступе к приложению.

- Конфликты с другими приложениями или сервисами: Несовместимость или
конфликты с другими установленными приложениями или сервисами на сервере
или в системе.

Примеры ошибок развёртывания программного обеспечения могут включать:
неправильная настройка файлов конфигурации, несовместимость версий
зависимых компонентов, проблемы с разрешением DNS-имен или сетевыми
подключениями.

93) Поясните принцип работы командного процессора и приведите
пример для ОС Linux
Командный процессор (Command Processor) - это интерпретатор команд,
который выполняет команды и обеспечивает взаимодействие между
пользователем и операционной системой. В ОС Linux одним из наиболее
распространенных командных процессоров является Bash (Bourne Again SHell).

Пример команды в командном процессоре Bash:
ls -l
Данная команда ls используется для отображения содержимого текущего
каталога, а опция -l указывает на вывод в длинном формате.
94) Система управления конфигурациями Ansible. Назначение,
краткая характеристика системы. Приведите примеры применения системы.
Ansible - система управления конфигурацией и оркестрации с открытым
исходным кодом. Она позволяет автоматизировать развертывание и управление
конфигурацией систем и приложений. Ansible использует язык описания
конфигурации YAML и основана на модели "инфраструктура как код".
Примеры применения системы Ansible:

- Автоматизация развертывания и настройки серверов в облаке.
- Управление конфигурацией и обновлением программного обеспечения на
физических или виртуальных серверах.
- Оркестрация приложений и сервисов в распределенной среде.
- Развёртывание инфраструктуры для разработки и тестирования приложений.
95) Архитектура Ansible. Преимущества системы управления
конфигурациями Ansible. Модули системы. Приведите примеры применения
Ansible.
Архитектура Ansible основана на клиент-серверной модели. Преимущества
системы управления конфигурацией Ansible:

- Простота и легковесность: Ansible не требует установки агентов на целевых

системах, и она основана на YAML-файлах, что делает ее легкой в
использовании и понимании.
- Избежание сложной инфраструктуры: Ansible использует простой и понятный
язык описания конфигурации, что позволяет избежать сложности в настройке
инфраструктуры.
- Широкие возможности автоматизации: Ansible поддерживает автоматизацию
различных задач, включая развертывание, настройку и управление
конфигурацией.
- Масштабируемость: Ansible позволяет масштабировать свои возможности и
применять в различных сценариях, от индивидуальных проектов до больших и
сложных инфраструктур.

Модули Ansible - это наборы предопределенных команд, которые выполняют
определенные задачи на целевых системах. Примеры модулей Ansible:
command, copy, apt, yum, service и др.
96) Решения по управлению конфигурацией компании «Систематика
- консалтинг».
Распределенная сборка (Distributed Build) - это процесс сборки
программного обеспечения, при котором задачи компиляции, сборки и
тестирования распределяются на несколько компьютеров или серверов для
повышения производительности и ускорения процесса.

Примеры распределенной сборки включают использование инструментов, таких
как Jenkins, TeamCity, или Travis CI, которые могут автоматизировать процесс
сборки, тестирования и развертывания программного обеспечения на различных
серверах или виртуальных машинах. Это позволяет распараллелить выполнение
задач и ускорить процесс разработки и развертывания программного
обеспечения
97) Сценарии (playbooks) Ansible. Основные понятия, назначение,
решаемые задачи. Приведите примеры сценариев
Сценарии (playbooks) Ansible - это файлы в формате YAML, которые содержат
набор инструкций и задач для автоматизации процессов управления
конфигурацией с использованием Ansible. Они определяют, какие действия
должны быть выполнены на целевых системах и в каком порядке. Основные
понятия, связанные с сценариями Ansible:

Хосты (Hosts): Определение группы целевых хостов, на которых будут
выполняться задачи.
Задачи (Tasks): Описание конкретных действий, которые необходимо
выполнить на целевых хостах.
Модули (Modules): Встроенные инструменты Ansible, которые выполняют
конкретные задачи на целевых хостах.
Переменные (Variables): Передача значений и параметров в сценарии для
настройки задач и модулей.
Роли (Roles): Организация сценариев и задач в логические блоки для
повторного использования и модульности.
Примеры сценариев Ansible могут включать:

Установка и настройка веб-сервера: Создание сценария, который
устанавливает веб-сервер на целевых хостах, настраивает его параметры и
развертывает веб-приложение.
Автоматизация развертывания приложений: Сценарий, который загружает
исходный код приложения из репозитория, устанавливает необходимые
зависимости, настраивает окружение и запускает приложение на целевых
хостах.
Управление конфигурацией сетевого оборудования: Сценарий, который
выполняет задачи по настройке и обновлению конфигурации на сетевых
устройствах, таких как маршрутизаторы и коммутаторы.
98) Опишите особенности графических и консольных клиентов на
примере Git.
Графические и консольные клиенты в Git имеют некоторые отличия в
интерфейсе и способе взаимодействия с Git-репозиторием.
Графические клиенты: Это приложения с графическим интерфейсом
пользователя (GUI), которые предоставляют визуальное представление
репозитория и инструменты для выполнения операций Git. Они обычно

имеют кнопки, меню и графические элементы для выполнения команд,
просмотра истории изменений, ветвлений и слияний в репозитории.
Примеры графических клиентов Git включают SourceTree, GitKraken,
GitHub Desktop.

Консольные клиенты: Это приложения, которые работают в командной
строке или терминале и предоставляют текстовый интерфейс для
выполнения команд Git. Они требуют ввода команд и аргументов вручную.
Консольные клиенты обычно используются опытными пользователями Git,
так как они предоставляют большую гибкость и функциональность для
выполнения сложных операций и автоматизации. Примеры консольных
клиентов Git включают Git Bash (входит в состав Git), Git Command Line,
PowerShell с установленным Git.

Основные особенности консольных клиентов включают:

Гибкий и мощный интерфейс командной строки.
Возможность выполнения сложных операций и настройки параметров.
Автоматизация с помощью сценариев и скриптов.
Широкие возможности управления репозиторием и историей коммитов.
99) Дайте характеристику трём этапам процесса: создание, состояние
и завершение
Процесс разработки программного обеспечения состоит из трех основных
этапов: создание, состояние и завершение.
Создание: Этот этап включает определение требований, проектирование
архитектуры, разработку и тестирование кода. В этом этапе создается
итеративно развивающаяся версия программного продукта.

Состояние: В этом этапе программное обеспечение находится в активном
состоянии использования. Оно выполняет свои функции, обслуживает
пользователей и может подвергаться изменениям и обновлениям на основе
обратной связи.

Завершение: Этот этап включает подготовку программного обеспечения к
выходу из эксплуатации. Это может быть связано с заменой программного
продукта новым, удалением его из системы или архивированием для хранения.
100) Системы управления конфигурацией. Инструменты управления
конфигурациями. Приведите примеры современных систем управления
конфигурацией.
Системы управления конфигурацией (Configuration Management Systems) -
это инструменты и практики, используемые для управления конфигурацией
программного обеспечения и инфраструктуры. Они обеспечивают
автоматизацию процессов развертывания, настройки и управления
конфигурацией системы.
Примеры современных систем управления конфигурацией:

Ansible: Инструмент для автоматизации конфигурации и оркестрации
системы.
Puppet: Инструмент для управления конфигурацией и автоматизации
развертывания.
Chef: Инструмент для управления конфигурацией и автоматизации
инфраструктуры.
SaltStack: Инструмент для автоматизации конфигурации и управления
системами.
Terraform: Инструмент для управления инфраструктурой как кодом.
101) Конфигурация программного обеспечения. Основные понятия,
состав, назначение, решаемые задачи. Приведите примеры конфигурации
программного обеспечения.
Конфигурация программного обеспечения - это совокупность настроек,
параметров и данных, которые определяют поведение программного
продукта. Она включает в себя все необходимые компоненты, файлы и
ресурсы, необходимые для корректной работы программы.
Основные понятия конфигурации программного обеспечения:

Файлы конфигурации: Файлы, содержащие настройки и параметры
программы.
Переменные окружения: Переменные, определенные в операционной
системе, которые влияют на работу программы.
Базы данных конфигурации: Хранилища данных, используемые для
хранения и доступа к конфигурационным настройкам.
Ресурсы и зависимости: Файлы, библиотеки и другие компоненты,
требуемые для работы программы.
Решаемые задачи конфигурации программного обеспечения:

Персонализация: Настройка программы под определенные потребности
пользователя.
Управление параметрами: Изменение и управление настройками и
параметрами программы.
Развертывание: Подготовка и настройка программного обеспечения для
запуска на конкретной системе.
Обновление и обслуживание: Модификация и обновление конфигурации
программы по мере необходимости.
102) Распределенная сборка. Определение, назначение, цели, типовые
действия при распределенной сборке. Приведите примеры распределенной
сборки.
Распределенная сборка (Distributed Build) - это процесс сборки программного
обеспечения, в котором задачи сборки распределяются между несколькими
компьютерами или устройствами в сети. Она позволяет ускорить процесс
сборки, улучшить масштабируемость и эффективность.
Назначение распределенной сборки:

Ускорение сборки: Распределение задач сборки между несколькими
компьютерами позволяет выполнять их параллельно, что сокращает время
сборки проекта.
Масштабируемость: Распределенная сборка позволяет масштабировать
процесс сборки, добавляя дополнительные ресурсы по мере необходимости.

Экономия ресурсов: Использование доступных компьютеров или устройств
для сборки позволяет оптимально распределить ресурсы и увеличить
эффективность.
Типовые действия при распределенной сборке:

Разделение задач: Разделение сборки проекта на независимые задачи,
которые могут быть распределены между устройствами.
Распределение задач: Распределение задач сборки между доступными
устройствами или компьютерами.
Синхронизация: Координация и синхронизация результатов сборки, чтобы
получить окончательный собранный продукт.
Примеры распределенной сборки включают использование инструментов,
таких как Apache Maven с его плагином для распределенной сборки, или
системы непрерывной интеграции, такой как Jenkins, с возможностью
параллельной сборки на нескольких агентах.
`,s=document.querySelector("#app"),c=l.split(/\d+\) /).slice(1);for(let o of c){const[i,n]=o.replace(`
`,"DELETE").split("DELETE"),r=document.createElement("h1");r.innerHTML=i,r.id=i;const e=document.createElement("span");e.innerHTML=n,s.appendChild(r),s.appendChild(e)}const u=document.querySelector("#input"),m=document.querySelectorAll("h1");function d(o){const i=o.target.value.toLowerCase();console.log(i),m.forEach(n=>{n.id.toLowerCase().includes(i)&&n.scrollIntoView()})}u.addEventListener("input",d);
